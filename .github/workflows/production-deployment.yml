name: Production Deployment Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment Type'
        required: true
        default: 'blue-green'
        type: choice
        options:
        - blue-green
        - rolling
        - canary
      skip_tests:
        description: 'Skip tests (emergency deployment only)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type || 'blue-green' }}

jobs:
  # Job 1: Pre-deployment Validation
  pre-deployment-validation:
    name: ðŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
      deployment_id: ${{ steps.validation.outputs.deployment_id }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate deployment conditions
        id: validation
        run: |
          DEPLOYMENT_ID="prod-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          
          # Check if this is a hotfix or regular deployment
          if [[ "${{ github.event.head_commit.message }}" == *"[hotfix]"* ]]; then
            echo "ðŸš¨ Hotfix deployment detected"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            echo "âš ï¸ Emergency deployment - skipping tests"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "ðŸ“‹ Regular deployment - full validation required"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Notify deployment start
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              channel: '#deployments',
              username: 'Production Deploy Bot',
              icon_emoji: ':rocket:',
              attachments: [{
                color: 'warning',
                title: 'ðŸš€ Production Deployment Started',
                fields: [{
                  title: 'Deployment ID',
                  value: '${{ steps.validation.outputs.deployment_id }}',
                  short: true
                }, {
                  title: 'Type',
                  value: '${{ env.DEPLOYMENT_TYPE }}',
                  short: true
                }, {
                  title: 'Commit',
                  value: '${{ github.sha }}',
                  short: true
                }, {
                  title: 'Branch',
                  value: '${{ github.ref_name }}',
                  short: true
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Job 2: Full Quality Gates (skipped for emergency deployments)
  quality-gates:
    name: ðŸ›¡ï¸ Quality Gates
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation]
    if: needs.pre-deployment-validation.outputs.should_deploy == 'false'
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run critical tests
        run: npm run test:critical
        
      - name: Run security scan
        run: |
          npm audit --audit-level=high --production
          npm run security:scan
          
      - name: Run performance tests
        run: |
          npm run build
          npm run test:performance
          
      - name: Check database migration safety
        run: |
          npm run db:check-migrations

  # Job 3: Build Production Image
  build-production:
    name: ðŸ—ï¸ Build Production Image
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation]
    if: always() && (needs.quality-gates.result == 'success' || needs.pre-deployment-validation.outputs.should_deploy == 'true')
    timeout-minutes: 20
    
    permissions:
      contents: read
      packages: write
      
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=production-${{ needs.pre-deployment-validation.outputs.deployment_id }}
            type=raw,value=latest-production
            type=sha,prefix=prod-
            
      - name: Build and push production image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=production
          cache-to: type=gha,mode=max,scope=production
          build-args: |
            NODE_ENV=production
            BUILD_ID=${{ needs.pre-deployment-validation.outputs.deployment_id }}

  # Job 4: Database Migration (if needed)
  database-migration:
    name: ðŸ—„ï¸ Database Migration
    runs-on: ubuntu-latest
    needs: [build-production]
    environment: production
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Check for pending migrations
        id: check_migrations
        run: |
          PENDING=$(npm run db:check-pending-migrations)
          echo "pending_migrations=$PENDING" >> $GITHUB_OUTPUT
          
      - name: Create database backup
        if: steps.check_migrations.outputs.pending_migrations != '0'
        run: |
          npm run db:backup --tag="pre-deployment-${{ needs.pre-deployment-validation.outputs.deployment_id }}"
          
      - name: Run database migrations
        if: steps.check_migrations.outputs.pending_migrations != '0'
        run: |
          npm run db:migrate
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          
      - name: Verify migration success
        if: steps.check_migrations.outputs.pending_migrations != '0'
        run: |
          npm run db:verify-migrations

  # Job 5: Blue-Green Deployment
  blue-green-deployment:
    name: ðŸ”„ Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production, database-migration]
    if: env.DEPLOYMENT_TYPE == 'blue-green'
    environment: production
    timeout-minutes: 30
    
    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
          
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          
      - name: Determine current environment
        id: current_env
        run: |
          export KUBECONFIG=kubeconfig
          CURRENT=$(kubectl get service inopnc-prod -o jsonpath='{.spec.selector.environment}')
          if [ "$CURRENT" = "blue" ]; then
            echo "current=blue" >> $GITHUB_OUTPUT
            echo "target=green" >> $GITHUB_OUTPUT
          else
            echo "current=green" >> $GITHUB_OUTPUT
            echo "target=blue" >> $GITHUB_OUTPUT
          fi
          echo "Current environment: $CURRENT, Target: $([ "$CURRENT" = "blue" ] && echo "green" || echo "blue")"
          
      - name: Deploy to target environment
        run: |
          export KUBECONFIG=kubeconfig
          TARGET=${{ steps.current_env.outputs.target }}
          
          # Update deployment with new image
          kubectl set image deployment/inopnc-$TARGET \
            app=${{ needs.build-production.outputs.image_tag }} \
            --record
            
          # Wait for rollout to complete
          kubectl rollout status deployment/inopnc-$TARGET --timeout=600s
          
      - name: Run health checks on target environment
        id: health_check
        run: |
          export KUBECONFIG=kubeconfig
          TARGET=${{ steps.current_env.outputs.target }}
          
          # Get target environment URL
          TARGET_URL=$(kubectl get service inopnc-$TARGET -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Health check with retries
          for i in {1..10}; do
            if curl -f https://$TARGET_URL/api/health; then
              echo "Health check passed"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              break
            fi
            echo "Health check $i failed, retrying in 30s..."
            sleep 30
          done
          
          if [ $i -eq 10 ]; then
            echo "Health check failed after 10 attempts"
            echo "health_status=unhealthy" >> $GITHUB_OUTPUT
          fi
          
      - name: Run smoke tests
        if: steps.health_check.outputs.health_status == 'healthy'
        run: |
          TARGET=${{ steps.current_env.outputs.target }}
          TARGET_URL=$(kubectl get service inopnc-$TARGET -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          npm ci
          npm run test:smoke -- --baseURL=https://$TARGET_URL
          
      - name: Switch traffic to new environment
        if: steps.health_check.outputs.health_status == 'healthy'
        run: |
          export KUBECONFIG=kubeconfig
          TARGET=${{ steps.current_env.outputs.target }}
          
          # Update main service to point to new environment
          kubectl patch service inopnc-prod -p '{"spec":{"selector":{"environment":"'$TARGET'"}}}'
          
          echo "Traffic switched to $TARGET environment"
          
      - name: Rollback on failure
        if: steps.health_check.outputs.health_status == 'unhealthy'
        run: |
          export KUBECONFIG=kubeconfig
          TARGET=${{ steps.current_env.outputs.target }}
          
          echo "Deployment failed, rolling back..."
          kubectl rollout undo deployment/inopnc-$TARGET
          
          exit 1

  # Job 6: Rolling Deployment (alternative strategy)
  rolling-deployment:
    name: ðŸ”„ Rolling Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production, database-migration]
    if: env.DEPLOYMENT_TYPE == 'rolling'
    environment: production
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
          
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          
      - name: Rolling update deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          # Perform rolling update
          kubectl set image deployment/inopnc-prod \
            app=${{ needs.build-production.outputs.image_tag }} \
            --record
            
          # Wait for rollout with timeout
          kubectl rollout status deployment/inopnc-prod --timeout=600s
          
      - name: Verify deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          # Check that all pods are ready
          kubectl get pods -l app=inopnc-prod
          
          # Run health check
          PROD_URL=$(kubectl get service inopnc-prod -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          curl -f https://$PROD_URL/api/health

  # Job 7: Canary Deployment (gradual rollout)
  canary-deployment:
    name: ðŸ¤ Canary Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-production, database-migration]
    if: env.DEPLOYMENT_TYPE == 'canary'
    environment: production
    timeout-minutes: 45
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
          
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          
      - name: Deploy canary (10% traffic)
        run: |
          export KUBECONFIG=kubeconfig
          
          # Deploy canary version
          kubectl apply -f k8s/canary-deployment.yaml
          kubectl set image deployment/inopnc-canary \
            app=${{ needs.build-production.outputs.image_tag }}
            
          # Update ingress to route 10% traffic to canary
          kubectl apply -f k8s/canary-ingress-10.yaml
          
      - name: Monitor canary metrics (5 minutes)
        run: |
          echo "Monitoring canary deployment for 5 minutes..."
          sleep 300
          
          # Check error rates and performance metrics
          npm run monitoring:check-canary-metrics
          
      - name: Increase canary traffic to 50%
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f k8s/canary-ingress-50.yaml
          
      - name: Monitor canary metrics (5 minutes)
        run: |
          echo "Monitoring 50% canary deployment for 5 minutes..."
          sleep 300
          
          npm run monitoring:check-canary-metrics
          
      - name: Complete canary deployment (100% traffic)
        run: |
          export KUBECONFIG=kubeconfig
          
          # Switch all traffic to canary
          kubectl apply -f k8s/canary-ingress-100.yaml
          
          # Scale down old deployment
          kubectl scale deployment/inopnc-prod --replicas=0
          
          # Rename canary to production
          kubectl patch deployment/inopnc-canary -p '{"metadata":{"name":"inopnc-prod"}}'

  # Job 8: Post-deployment Verification
  post-deployment-verification:
    name: âœ… Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [blue-green-deployment, rolling-deployment, canary-deployment]
    if: always() && (needs.blue-green-deployment.result == 'success' || needs.rolling-deployment.result == 'success' || needs.canary-deployment.result == 'success')
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run production smoke tests
        run: |
          npm run test:smoke:production
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
          
      - name: Verify critical functionality
        run: |
          npm run test:critical:production
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
          
      - name: Check performance metrics
        run: |
          npm run monitoring:check-production-metrics
          
      - name: Update deployment status
        run: |
          # Mark deployment as successful in monitoring system
          curl -X POST "${{ secrets.DEPLOYMENT_WEBHOOK }}" \
            -H "Content-Type: application/json" \
            -d '{
              "deployment_id": "${{ needs.pre-deployment-validation.outputs.deployment_id }}",
              "status": "success",
              "image": "${{ needs.build-production.outputs.image_tag }}",
              "timestamp": "'$(date -Iseconds)'"
            }'

  # Job 9: Cleanup Old Resources
  cleanup:
    name: ðŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [post-deployment-verification]
    if: always() && needs.post-deployment-verification.result == 'success'
    timeout-minutes: 10
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
          
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          
      - name: Cleanup old container images
        run: |
          # Keep last 5 production images
          docker image prune -af --filter "until=168h"
          
      - name: Cleanup old database backups
        run: |
          # Keep backups for last 30 days
          npm run db:cleanup-backups --days=30

  # Job 10: Notification
  deployment-notification:
    name: ðŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, post-deployment-verification, blue-green-deployment, rolling-deployment, canary-deployment]
    if: always()
    
    steps:
      - name: Determine deployment result
        id: result
        run: |
          if [[ "${{ needs.post-deployment-verification.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
            echo "emoji=âœ…" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
          fi
          
      - name: Notify deployment result
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              channel: '#deployments',
              username: 'Production Deploy Bot',
              icon_emoji: ':rocket:',
              attachments: [{
                color: '${{ steps.result.outputs.color }}',
                title: '${{ steps.result.outputs.emoji }} Production Deployment ${{ steps.result.outputs.status == 'success' && 'Completed' || 'Failed' }}',
                fields: [{
                  title: 'Deployment ID',
                  value: '${{ needs.pre-deployment-validation.outputs.deployment_id }}',
                  short: true
                }, {
                  title: 'Strategy',
                  value: '${{ env.DEPLOYMENT_TYPE }}',
                  short: true
                }, {
                  title: 'Commit',
                  value: '${{ github.sha }}',
                  short: true
                }, {
                  title: 'Duration',
                  value: '${{ github.run_number }} minutes',
                  short: true
                }],
                footer: 'Production Deployment Pipeline',
                ts: '${{ github.event.head_commit.timestamp }}'
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Create deployment record
        if: steps.result.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment via ${{ env.DEPLOYMENT_TYPE }} strategy',
              auto_merge: false,
              required_contexts: []
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              description: 'Deployment completed successfully',
              environment_url: '${{ secrets.PRODUCTION_URL }}'
            });

# Emergency rollback workflow (can be triggered manually)
  emergency-rollback:
    name: ðŸš¨ Emergency Rollback
    runs-on: ubuntu-latest
    if: github.event.inputs.deployment_type == 'rollback'
    environment: production
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
          
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          
      - name: Rollback to previous version
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout undo deployment/inopnc-prod
          kubectl rollout status deployment/inopnc-prod --timeout=300s
          
      - name: Verify rollback
        run: |
          export KUBECONFIG=kubeconfig
          PROD_URL=$(kubectl get service inopnc-prod -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          curl -f https://$PROD_URL/api/health
          
      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              channel: '#alerts',
              username: 'Emergency Rollback Bot',
              icon_emoji: ':warning:',
              attachments: [{
                color: 'warning',
                title: 'ðŸš¨ Emergency Rollback Completed',
                text: 'Production has been rolled back to the previous stable version.',
                footer: 'Emergency Response Team',
                ts: '${{ github.event.head_commit.timestamp }}'
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}